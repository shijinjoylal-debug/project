<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EmerTezora — Superposition (Interactive)</title>
<style>
  input[type="range"] {
  touch-action: pan-y;
  height: 28px;
}
@media (max-width:600px){
  .container { margin: 48px auto; }
}

  :root{
    --bg:#071427;
    --panel:#0b1220;
    --accent:#7fd1ff;
    --muted: rgba(255,255,255,0.08);
    --glass: rgba(255,255,255,0.04);
    --text: #eaf6ff;
    --glass-strong: rgba(255,255,255,0.06);
    --blur: 6px;
    --radius: 14px;
  }

  html,body{height:100%; margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:
    radial-gradient(900px 600px at 20% 10%, #06203b 0%, var(--bg) 40%, #040514 100%); color:var(--text);}
  .container{
    max-width:1100px; margin:72px auto; padding:28px; box-sizing:border-box;
    display:grid; grid-template-columns: 1fr 360px; gap:28px; align-items:start;
  }

  /* Header */
  header{ grid-column: 1 / -1; display:flex; justify-content:space-between; align-items:center; gap:16px;}
  .title{
    display:flex; gap:16px; align-items:center;
  }
  .logo {
    width:78px; height:78px; border-radius:12px; display:grid; place-items:center;
    background:linear-gradient(135deg, rgba(127,209,255,0.06), rgba(127,209,255,0.02));
    box-shadow: 0 6px 24px rgba(34,58,77,0.45), inset 0 0 0 1px rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.03);
  }
  .title h1{font-size:20px; margin:0; letter-spacing:0.06em;}
  .title p{margin:0; font-size:12px; color:rgba(234,246,255,0.7);}

  /* Panel styles */
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius: var(--radius);
    padding:16px;
    box-shadow: 0 8px 32px rgba(3,8,18,0.6), inset 0 0 0 1px rgba(255,255,255,0.02);
    backdrop-filter: blur(var(--blur));
    border: 1px solid var(--glass-strong);
  }

  /* Left: simulation area */
  .sim-wrap{ min-height:420px; display:flex; flex-direction:column; gap:16px; }
  .canvas-wrap{
    position:relative; border-radius:12px; overflow:hidden; padding:18px;
    background:linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.08));
    border:1px solid rgba(127,209,255,0.04);
  }
  canvas { display:block; width:100%; height:320px; background:transparent; }

  .controls{
    display:flex; gap:12px; align-items:center; margin-top:8px;
  }

  .btn{
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border:1px solid rgba(127,209,255,0.08);
    color:var(--text); padding:12px 14px; border-radius:10px; cursor:pointer;
    font-weight:600; font-size:13px; transition:transform .12s ease, box-shadow .12s;
  }
  .btn:hover{ transform:translateY(-3px); box-shadow:0 10px 30px rgba(127,209,255,0.08); }
  .btn.primary{
    background: linear-gradient(90deg, rgba(127,209,255,0.14), rgba(127,209,255,0.08));
    box-shadow: 0 8px 30px rgba(127,209,255,0.08);
    border: 1px solid rgba(127,209,255,0.18);
  }

  .small{
    font-size:12px; opacity:0.85; padding:8px 10px; border-radius:8px;
  }

  /* Right: explanation column */
  .info{ display:flex; flex-direction:column; gap:12px; }
  .card{ padding:12px; border-radius:12px; border:1px solid var(--glass); background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008)); }
  .card h3{ margin:0 0 6px 0; font-size:15px; }
  .card p{ margin:0; font-size:13px; line-height:1.45; color:rgba(234,246,255,0.9); }

  .note{ font-size:12px; color:rgba(234,246,255,0.78); opacity:0.95; }

  /* popup / toast */
  .toast{
    position:absolute; left:50%; transform:translateX(-50%); bottom:22px; z-index:40;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:10px 14px; border-radius:10px; border:1px solid rgba(127,209,255,0.08);
    box-shadow: 0 10px 30px rgba(6,30,48,0.6); font-weight:700; font-size:13px;
    display:none;
  }

  /* footer nav */
  .nav-links{ display:flex; gap:10px; align-items:center; }
  .link-ghost{ font-size:13px; color:rgba(234,246,255,0.8); text-decoration:none; padding:8px; border-radius:8px; }
  .link-ghost:hover{ color:var(--accent); }

  /* small responsive */
  @media (max-width:980px){
    .container{ grid-template-columns: 1fr; padding:18px; gap:18px; }
    .sim-wrap{ order:1 } .info{ order:2 }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <div class="title">
      <div class="logo" aria-hidden="true">
        <!-- small SVG motif -->
        <svg viewBox="0 0 36 36" width="46" height="46" fill="none" aria-hidden="true">
          <circle cx="18" cy="18" r="10" stroke="rgba(127,209,255,0.28)" stroke-width="1.6"/>
          <path d="M8 18c4-6 20-6 20 0" stroke="url(#g)" stroke-width="1.8" stroke-linecap="round"/>
          <defs>
            <linearGradient id="g" x1="0" x2="1"><stop offset="0" stop-color="#bfe9ff"/><stop offset="1" stop-color="#7fd1ff"/></linearGradient>
          </defs>
        </svg>
      </div>
      <div>
        <h1>Superposition</h1>
        <p>Interactive lab — see a quantum state collapse in real time</p>
      </div>
    </div>
  </header>

  <!-- Simulation Column -->
  <section class="panel sim-wrap" aria-labelledby="sim-title">
    <div class="canvas-wrap" style="position:relative;">
      <h2 id="sim-title" style="margin:0 0 12px 0; font-size:16px;">Superposition visualizer</h2>
      <!-- Canvas for wave rendering -->
      <canvas id="waveCanvas" width="800" height="320" role="img" aria-label="Animated wave representing superposition"></canvas>

      <!-- toast / popup -->
      <div id="toast" class="toast" role="status" aria-live="polite">Observation: wave collapsed</div>
    </div>

    <!-- controls -->
    <div class="controls">
      <button id="observeBtn" class="btn primary" aria-pressed="false">Observe (Collapse)</button>
      <button id="restartBtn" class="btn small">Restart</button>
      <div style="flex:1"></div>
      <label style="font-size:13px; color:rgba(234,246,255,0.75);">
        Amplitude
        <input id="amp" type="range" min="0.3" max="2.2" step="0.1" value="1" style="vertical-align:middle;margin-left:8px;">
      </label>
    </div>

    <p class="note" style="margin-top:6px;">
      Tip: Click <strong>Observe</strong> to cause a collapse. Use <strong>Restart</strong> to reset the superposition.
    </p>
  </section>

  <!-- Explanation Column -->
  <aside class="info">
    <div class="card">
      <h3>What you’ll see</h3>
      <p>Two wave-like possibilities are shown (this is an analogy). The bright combined pattern is the superposition. When you "observe", the superposition collapses into a single measurement — represented by a dot at one location.</p>
    </div>

    <div class="card">
      <h3>Interactive cues</h3>
      <p>After observing, a short explanatory pop-up appears and (optionally) voice feedback announces the result.</p>
    </div>

    <div class="card">
      <h3>Quick facts</h3>
      <p>Superposition means a quantum system can be in many states simultaneously. Measurement forces the system into one of the possible states — the outcome is probabilistic, not deterministic.</p>
    </div>
  </aside>

</div>

<script>
  function resize() {
  const rect = canvas.getBoundingClientRect();
  const scale = window.devicePixelRatio || 1;
  canvas.width = Math.max(600, Math.floor(rect.width * scale));
  canvas.height = 320 * scale;
  ctx.scale(scale, scale);
  W = canvas.width / scale;
  H = canvas.height / scale;
}

/*
 Lightweight Superposition visualizer
 - Animates two gaussian-like waves and their sum (superposition)
 - "Observe" collapses to a single random position (sampled from probability distribution)
 - Restart resets animation
 - Minimal dependencies, works with plain JS + canvas
*/

// ---------- Utilities ----------
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
let W = canvas.width, H = canvas.height;
function resize() {
  // keep internal resolution in ratio for crispness
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(600, Math.floor(rect.width * 1.0));
  canvas.height = 320;
  W = canvas.width; H = canvas.height;
}
resize();
window.addEventListener('resize', () => { resize(); drawFrame(); });

// parameters
let t = 0;
let running = true;
let amplitudeControl = document.getElementById('amp');

const params = {
  speed: 0.012,
  amp: parseFloat(amplitudeControl.value),
  sigma: 0.08,           // controls width of each gaussian
  centerSeparation: 0.18 // relative positions of two basis states
};

// probability density function (normalized) will be computed from combined wave amplitude squared
const toast = document.getElementById('toast');
const observeBtn = document.getElementById('observeBtn');
const restartBtn = document.getElementById('restartBtn');

amplitudeControl.addEventListener('input', (e) => { params.amp = parseFloat(e.target.value); });

// ---------- Math helpers (1D) ----------
function gaussian(x, mu, sigma) {
  const a = 1 / (Math.sqrt(2*Math.PI) * sigma);
  return a * Math.exp(-0.5 * ((x-mu)/sigma)**2);
}

// create two basis gaussians on domain [0,1]
function basisWave(x, mu, phase=0, k=20) {
  // small oscillatory factor to create wave-like look
  return gaussian(x, mu, params.sigma) * Math.cos(2*Math.PI*k*(x) + phase);
}

// compute combined wave function (psi) at discrete x
function computePsiArray(phaseShift=0) {
  const n = W;
  const psi = new Float32Array(n);
  const mu1 = 0.5 - params.centerSeparation;
  const mu2 = 0.5 + params.centerSeparation;
  for (let i=0;i<n;i++){
    const x = i / (n-1);
    // simple superposition: equal weight 1/sqrt(2)
    const a1 = basisWave(x, mu1, phaseShift, 18);
    const a2 = basisWave(x, mu2, -phaseShift, 18);
    psi[i] = params.amp * (a1 + a2);
  }
  return psi;
}

// compute probability density (|psi|^2) normalized
function computeDensity(psi) {
  const n = psi.length;
  const density = new Float32Array(n);
  let sum = 0;
  for (let i=0;i<n;i++){ density[i] = psi[i]*psi[i]; sum += density[i]; }
  if (sum === 0) return density;
  const norm = 1 / sum;
  for (let i=0;i<n;i++) density[i] *= norm;
  return density;
}

// sample an index from discrete distribution density
function sampleIndex(density) {
  const r = Math.random();
  let c = 0;
  for (let i=0;i<density.length;i++){
    c += density[i];
    if (r <= c) return i;
  }
  return density.length - 1;
}

// ---------- Drawing ----------
function clear() {
  ctx.clearRect(0,0,W,H);
  // subtle background grid lines
  ctx.fillStyle = 'rgba(255,255,255,0.01)';
  ctx.fillRect(0,0,W,H);
}

function drawFrame() {
  clear();
  // compute frames with small time variant
  const phase = Math.sin(t*0.9) * 0.9;
  const psi = computePsiArray(phase);
  const density = computeDensity(psi);

  // draw axis baseline
  ctx.beginPath();
  ctx.moveTo(0, H*0.7);
  ctx.lineTo(W, H*0.7);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // draw density as translucent glow
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, 'rgba(127,209,255,0.14)');
  grad.addColorStop(1, 'rgba(127,209,255,0.02)');
  ctx.fillStyle = grad;

  // density path (filled)
  ctx.beginPath();
  ctx.moveTo(0, H);
  for (let i=0;i<W;i++){
    const x = i;
    const y = H*0.7 - density[i]*H*0.6*6; // exaggerate for visibility
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, H);
  ctx.closePath();
  ctx.fill();

  // draw wave outline (psi)
  ctx.beginPath();
  for (let i=0;i<W;i++){
    const x = i;
    const y = H*0.7 - psi[i]*H*0.22;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = 'rgba(191,233,255,0.86)';
  ctx.lineWidth = 1.8;
  ctx.stroke();

  // second thin glowing trace
  ctx.beginPath();
  for (let i=0;i<W;i++){
    const x = i;
    const y = H*0.7 - psi[i]*H*0.12;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = 'rgba(127,209,255,0.28)';
  ctx.lineWidth = 6;
  ctx.globalAlpha = 0.12;
  ctx.stroke();
  ctx.globalAlpha = 1;

  // small moving particle markers at high-probability zones
  const peakCount = 3;
  for (let k=0;k<peakCount;k++){
    const idx = Math.floor((k+0.5) * W/(peakCount+1) + Math.sin(t*0.7 + k)*10);
    const px = idx;
    const py = H*0.7 - psi[idx]*H*0.22;
    ctx.beginPath();
    ctx.arc(px, py, 3.2, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.74)';
    ctx.fill();
  }
}

// animation loop
function step() {
  if (running) {
    t += params.speed;
    drawFrame();
  }
  requestAnimationFrame(step);
}
step();

// ---------- Observation (collapse) ----------
let hasCollapsed = false;
function showToast(msg, delay=1800) {
  toast.textContent = msg;
  toast.style.display = 'block';
  toast.style.opacity = 1;
  setTimeout(()=> {
    toast.style.transition = 'opacity 360ms ease';
    toast.style.opacity = 0;
    setTimeout(()=> { toast.style.display = 'none'; toast.style.transition = ''; }, 380);
  }, delay);
}

function speak(text) {
  if (!('speechSynthesis' in window)) return;
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = navigator.language || 'en-US';
  utter.rate = 1.02; utter.pitch = 1.0;
  window.speechSynthesis.cancel(); // avoid overlapping
  window.speechSynthesis.speak(utter);
}

function collapse() {
  if (hasCollapsed) return;
  hasCollapsed = true;
  running = false;
  observeBtn.setAttribute('aria-pressed','true');

  // compute psi & density at collapse moment
  const psi = computePsiArray(Math.sin(t*0.9)*0.9);
  const density = computeDensity(psi);

  // sample an index (probabilistic outcome)
  const idx = sampleIndex(density);
  const x = idx;
  const y = H*0.7 - psi[idx]*H*0.22;

  // fade canvas slightly and draw a single bright particle
  ctx.globalCompositeOperation = 'source-over';
  // dim background
  ctx.fillStyle = 'rgba(2,6,10,0.45)';
  ctx.fillRect(0,0,W,H);

  // draw the chosen dot big and glowing
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, 30);
  gradient.addColorStop(0, 'rgba(255,255,255,0.98)');
  gradient.addColorStop(0.25, 'rgba(191,233,255,0.9)');
  gradient.addColorStop(0.5, 'rgba(127,209,255,0.45)');
  gradient.addColorStop(1, 'rgba(127,209,255,0.03)');

  ctx.beginPath();
  ctx.fillStyle = gradient;
  ctx.arc(x, y, 18, 0, Math.PI*2);
  ctx.fill();

  // small crisp dot
  ctx.beginPath(); ctx.arc(x, y, 4.2, 0, Math.PI*2);
  ctx.fillStyle = '#031722';
  ctx.fill();

  // informational popup + voice
  const measuredX = (idx / W).toFixed(3);
  showToast(`Observed at x ≈ ${measuredX}`);
  try { speak(`Observation result: position ${measuredX}`); } catch(e){}

  // add a descriptive card result in the right info column (non persistent)
  const resultCard = document.createElement('div');
  resultCard.className = 'card';
  resultCard.style.marginTop = '10px';
  resultCard.innerHTML = `<h3>Measurement result</h3>
    <p>The system collapsed to one definite outcome at x ≈ <strong>${measuredX}</strong>. Note that repeated observations may yield different positions — the pattern is probabilistic.</p>`;
  document.querySelector('.info').prepend(resultCard);
}

// ---------- Buttons ----------
observeBtn.addEventListener('click', () => {
  collapse();
});

restartBtn.addEventListener('click', () => {
  // reset state and remove any previous result cards
  hasCollapsed = false;
  running = true;
  observeBtn.setAttribute('aria-pressed','false');
  // remove ephemeral result cards (first .card which is a measurement result)
  const info = document.querySelector('.info');
  const cards = info.querySelectorAll('.card');
  // remove cards that contain "Measurement result" heading
  cards.forEach(c => {
    if (c.textContent && c.textContent.includes('Measurement result')) c.remove();
  });
  // redraw fresh
  t = 0;
  drawFrame();
});

// keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === ' '){ e.preventDefault(); if (!hasCollapsed) collapse(); }
  if (e.key.toLowerCase() === 'r'){ restartBtn.click(); }
});

// small accessibility: announce state on load
window.setTimeout(()=> {
  showToast('Ready — click Observe to collapse the superposition', 1600);
}, 700);

</script>
</body>
</html>
